<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CPP DiTTA Interactive Model</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <style>
    body {
      font-family: 'Montserrat', sans-serif;
      background-color: #ffffff;
      color: #000000;
    }

    .navbar-custom {
      background: url("static/cpp_campus.png") no-repeat center center;
      background-size: cover;
      position: relative;
    }

    .navbar-custom .navbar-brand,
    .navbar-custom .nav-link {
      color: white !important;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px 1px 0 #000,
         1px 1px 0 #000;
    }

    .navbar-custom .navbar-brand {
      display: flex;
      align-items: center;
    }

    .navbar-custom .navbar-brand img {
      margin-right: 10px;
    }

    .navbar-custom .navbar-nav .nav-link {
      margin-right: 15px;
    }

    .content-wrapper {
      background-color: #ffffff;
      margin: 45px auto;
      padding: 45px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      max-width: 1200px;
      overflow: visible
    }

    h1, h2, h3, h4, h5, h6 {
      font-family: "Roboto Mono", monospace;
    }

    .input-container {
      max-width: 1000px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      flex-wrap: nowrap;
    }

    .input-wrapper {
      text-align: center;
      flex: 1;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .btn-secondary {
      padding: 5px;
      font-size: 0.8em;
      width: 30px;
      height: 30px;
      text-align: center;
    }

    input[type="number"].form-control {
      width: 80px;
      text-align: center;
    }

    input[type="number"].form-control::-webkit-outer-spin-button,
    input[type="number"].form-control::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    button[type="submit"],
    .btn-success {
      border-radius: 5px;
    }

    canvas {
      width: 960px !important;
      height: 400px !important;
      max-width: none !important;
      max-height: none !important;
      display: block;
      margin: 0 auto;
      background: #000;
}

  </style>
</head>

<body>
  <!-- NAVBAR -->
  <nav class="navbar navbar-expand-lg navbar-custom">
    <a class="navbar-brand" href="index.html">
      <img src="static/cpp_logo.png" width="209" height="50" class="d-inline-block align-top" alt="CPP Logo">
      CPP DiTTA
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
      aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item"><a class="nav-link" href="about.html">About DiTTA</a></li>
        <li class="nav-item"><a class="nav-link" href="index.html">Interactive Model</a></li>
      </ul>
    </div>
  </nav>

  <!-- MAIN CONTENT -->
  <div class="container">
    <div class="content-wrapper">
      <h1 class="text-center my-4">CPP-DiTTA Interactive Model</h1>
      <h1 class="text-center my-4">Step 1 - Predicting Damage Location</h1>

      <div class="text-center">
        <p class="lead">First, seven sensors are used to read stress values along the length of the 24-inch beam. The values of these sensors will give insight into the location of any damage along the beam, if any.</p>
        <p class="lead">Input stress values for each node on the beam. These may range from 0 to 10,000 psi.</p>
      </div>

      <div class="text-center my-4">
        <h4>Select a Stress Scenario:</h4>
        <div class="btn-group" role="group">
          <button class="btn btn-outline-primary mx-2" onclick="setCase([8200,4541,3347,1797,1322,877,475])">Case 1</button>
          <button class="btn btn-outline-primary mx-2" onclick="setCase([7186,7316,3316,1794,1320,876,475])">Case 2</button>
          <button class="btn btn-outline-primary mx-2" onclick="setCase([4846,4848,3778,1782,1315,874,474])">Case 3</button>
          <button class="btn btn-outline-primary mx-2" onclick="setCase([4826,4402,4084,1746,1296,865,469])">Case 4</button>
          <button class="btn btn-outline-primary mx-2" onclick="setCase([4822,4394,3360,4294,1470,828,441])">Case 5</button>
          <button class="btn btn-outline-primary mx-2" onclick="setCase([4819,4390,3350,1819,1428,1844,527])">Case 6</button>
          <button class="btn btn-outline-primary mx-2" onclick="setCase([4818,4389,3348,1804,1347,998,1028])">Case 7</button>
        </div>
      </div>

      <form id="sensorForm">
        <div class="text-center my-4">
          <h4>Adjust Stress Values to See the Result:</h4>
          <div class="input-container" id="inputContainer"></div>
        </div>
        <button type="button" class="btn btn-success btn-lg my-4" onclick="runNN1Prediction()">Run Machine Learning Model</button>

      </form>

      <div id="ml-result-container" class="text-center my-4"></div>

      <div class="text-center my-5">
        <canvas id="unityContainer" width="960" height="400" style="background:#000; display:block; margin:0 auto;"></canvas>
      </div>

      <div class="text-center">
        <h1 class="text-center my-4">Step 2 - Predicting Stress Field</h1>
        <p class="lead">The predicted cut location can be passed to a second model, which will generate a stress field showing stress on the beam after the damage.</p>
      </div>

      <div class="text-center my-3">
        <button class="btn btn-success btn-lg my-4" onclick="runNN2()">Generate Stress Field</button>
      </div>

      <div class="text-center my-5">
        <canvas id="unityContainer2" width="960" height="400" style="background:#000; display:block; margin:0 auto;"></canvas>
      </div>

      <div class="text-center my-4">
        <img src="static/psi_gradient.png" alt="NN2 Output Visualization" style="max-width:50%; height:auto;">
      </div>
    </div>
  </div>

  <script>
    // --- Generate input sliders dynamically ---
    const probes = ["4in","6in","10in","16in","18in","20in","22in"];
    const container = document.getElementById("inputContainer");
    probes.forEach((label,i)=>{
      const id=`input${i+1}`;
      container.innerHTML += `
        <div class="input-wrapper">
          <label for="${id}" class="input-label">${label} Probe</label>
          <div class="input-group">
            <button class="btn btn-secondary btn-sm" onclick="adjustInput('${id}',100)">&#x25B2;</button>
            <button class="btn btn-secondary btn-sm" onclick="adjustInput('${id}',1000)">&#x25B2;</button>
            <input type="number" id="${id}" name="${id}" class="form-control text-center" value="0" min="0" max="20000" step="any">
            <button class="btn btn-secondary btn-sm" onclick="adjustInput('${id}',-1000)">&#x25BC;</button>
            <button class="btn btn-secondary btn-sm" onclick="adjustInput('${id}',-100)">&#x25BC;</button>
          </div>
        </div>`;
    });
    
    function adjustInput(id,inc){
          const input=document.getElementById(id);
          let val=parseFloat(input.value)+inc;
          if(val<0) val=0;
          if(val>20000) val=20000;
          input.value=val;
        }

        function setCase(values){
          values.forEach((v,i)=>document.getElementById(`input${i+1}`).value=v);
        }
        
    let nn1Session = null;
    let nn1Scaler = null;

    // Load ONNX model once
    async function loadNN1() {
      if (nn1Session) return nn1Session;
      console.log("Loading NN1 model...");
      nn1Session = await ort.InferenceSession.create('./models/NN1_trained_model.onnx');
      console.log("NN1 model loaded.");
      return nn1Session;
    }

    // Load the StandardScaler parameters (mean & scale)
    async function loadScaler() {
      if (nn1Scaler) return nn1Scaler;
      const res = await fetch('./models/NN1_scaler.json');
      nn1Scaler = await res.json();
      console.log("Scaler loaded:", nn1Scaler);
      return nn1Scaler;
    }

    // Run NN1 inference
    async function runNN1Prediction() {
      const session = await loadNN1();
      const scaler = await loadScaler();

      // collect user inputs
      const inputs = [];
      for (let i = 1; i <= 7; i++) {
        inputs.push(parseFloat(document.getElementById(`input${i}`).value) || 0);
      }

      // apply StandardScaler: (x - mean) / scale
      const scaled = inputs.map((x, i) => (x - scaler.mean[i]) / scaler.scale[i]);

      // create tensor [1,7]
      const inputTensor = new ort.Tensor('float32', Float32Array.from(scaled), [1, 7]);

      // feed dictionary â€” adjust key if ONNX input name differs
      const feeds = { [session.inputNames[0]]: inputTensor };

      
      document.getElementById("ml-result-container").innerHTML = `<div class="spinner-border text-primary" role="status"><span class="sr-only">Running...</span></div>`;


      // run inference
      const results = await session.run(feeds);
      const outputName = Object.keys(results)[0];
      const yPred = results[outputName].data[0];

      displayPrediction(yPred);
    }

    function displayPrediction(yPred) {
      const result = yPred.toFixed(2);
      document.getElementById("ml-result-container").innerHTML =
        `<div class="alert alert-info"><h3>Predicted Cut Location: ${result} inches</h3></div>`;
      document.getElementById("ml-result-container").dataset.prediction = result;

      // --- NEW: Send to Unity (Scene 1 visualization)
      if (window.unityInstance1) {
        console.log("Sending cut location to Unity:", result);
        window.unityInstance1.SendMessage("CutPositionManager", "ReceivePrediction", result);
      } else {
        console.warn("Unity instance not ready yet");
      }
    }

    let nn3Session = null;
    let scalerX = null;
    let scalerY = null;

    // Load NN3 model
    async function loadNN3() {
      if (nn3Session) return nn3Session;
      console.log("Loading NN3 model...");
      nn3Session = await ort.InferenceSession.create('./models/NN3.onnx');
      console.log("NN3 model loaded.");
      return nn3Session;
    }

    // Load normalization scalers
    async function loadNN3Scalers() {
      if (scalerX && scalerY) return { scalerX, scalerY };

      const [resX, resY] = await Promise.all([
        fetch('./models/scaler_X_nn3_noEng.json').then(r => r.json()),
        fetch('./models/scaler_y_nn3_noEng.json').then(r => r.json())
      ]);

      scalerX = resX;
      scalerY = resY;
      console.log("NN3 scalers loaded:", scalerX, scalerY);
      return { scalerX, scalerY };
    }

    // Normalization helpers
    function normalizeInput(val, idx) {
      // Handles either min_/max_ or scale_ depending on sklearn type
      if (scalerX.min_) {
        // If using MinMaxScaler
        const min = scalerX.data_min_[idx];
        const max = scalerX.data_max_[idx];
        return (val - min) / (max - min);
      } else if (scalerX.scale_) {
        // If using StandardScaler (mean/std)
        const mean = scalerX.mean_[idx];
        const scale = scalerX.scale_[idx];
        return (val - mean) / scale;
      } else {
        console.warn("Unknown scaler format for X:", scalerX);
        return val;
      }
    }

    function denormalizeOutput(val, idx = 0) {
       // Handles either min_/max_ or scale_ for Y scaler
      if (scalerY.data_min_) {
        const min = scalerY.data_min_[idx];
        const max = scalerY.data_max_[idx];
        return val * (max - min) + min;
      } else if (scalerY.scale_) {
        const mean = scalerY.mean_[idx];
        const scale = scalerY.scale_[idx];
        return val * scale + mean;
      } else {
        console.warn("Unknown scaler format for Y:", scalerY);
        return val;
      }
    }

    async function runNN2() {
      const result = document.getElementById("ml-result-container").dataset.prediction || "unknown";

      if (result === "unknown") {
        alert("Please run the machine learning model first.");
        return;
      }

      const cutLocation = parseFloat(result);
      const forceValue = 1000; // You can adjust or get this from user input later

      const [session, scalers] = await Promise.all([loadNN3(), loadNN3Scalers()]);
      const { scalerX, scalerY } = scalers;

      const points = [];
      const gridSizeX = 20, gridSizeY = 5, gridSizeZ = 1;
      const xRange = [0, 24];   // inches across beam
      const yRange = [0, 1];    // normalized beam thickness
      const zValue = 0;         // flat beam assumption

      console.log("Running NN3 predictions across grid...");

      for (let ix = 0; ix < gridSizeX; ix++) {
        for (let iy = 0; iy < gridSizeY; iy++) {
          const x = xRange[0] + (xRange[1] - xRange[0]) * (ix / (gridSizeX - 1));
          const y = yRange[0] + (yRange[1] - yRange[0]) * (iy / (gridSizeY - 1));
          const z = zValue;

          // Normalize input
          const inputNorm = Float32Array.from([
            normalizeInput(x, 0),
            normalizeInput(y, 1),
            normalizeInput(z, 2),
            normalizeInput(cutLocation, 3),
            normalizeInput(forceValue, 4)
          ]);

          const inputTensor = new ort.Tensor('float32', inputNorm, [1, 5]);

          // Run inference
          const feeds = { [session.inputNames[0]]: inputTensor };
          const results = await session.run(feeds);
          const outputName = Object.keys(results)[0];
          const stressNorm = results[outputName].data[0];

          // Denormalize
          const stress = denormalizeOutput(stressNorm);

          points.push({ x, y, z, stress });
        }
      }

      console.log(`Predicted ${points.length} stress values.`);

      const jsonData = JSON.stringify(points);

      if (window.unityInstance2) {
        console.log("Sending stress field JSON to Unity...");
        window.unityInstance2.SendMessage("WebDataReceiver", "ReceiveStressData", jsonData);
      } else {
        console.warn("Unity instance 2 not ready yet");
      }
    }
      </script>

  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>

  <!--  Controlled Unity initialization -->
<script>
async function loadUnityNN1() {
  const script = document.createElement("script");
  script.src = "static/UnityBuild_NN1/WebGL_NN1_Build4.loader.js";
  document.body.appendChild(script);
  await new Promise(res => (script.onload = res));

  const buildUrl = "static/UnityBuild_NN1";
  const config = {
    dataUrl: buildUrl + "/WebGL_NN1_Build4.data",
    frameworkUrl: buildUrl + "/WebGL_NN1_Build4.framework.js",
    codeUrl: buildUrl + "/WebGL_NN1_Build4.wasm",
    streamingAssetsUrl: "StreamingAssets",
    companyName: "CPP",
    productName: "DiTTA NN1",
    productVersion: "1.0",
  };

  const canvas = document.getElementById("unityContainer");
  return createUnityInstance(canvas, config, (p) => {
    console.log(`NN1 loading: ${Math.round(p * 100)}%`);
  }).then((unityInstance) => {
    window.unityInstance1 = unityInstance;
    console.log("NN1 Unity initialized!");
  }).catch((err) => console.error("NN1 failed:", err));
}

async function loadUnityNN2() {
  const script = document.createElement("script");
  script.src = "static/UnityBuild_NN2/WebGL_NN2_Build2.loader.js";
  document.body.appendChild(script);
  await new Promise(res => (script.onload = res));

  const buildUrl = "static/UnityBuild_NN2";
  const config = {
    dataUrl: buildUrl + "/WebGL_NN2_Build2.data",
    frameworkUrl: buildUrl + "/WebGL_NN2_Build2.framework.js",
    codeUrl: buildUrl + "/WebGL_NN2_Build2.wasm",
    streamingAssetsUrl: "StreamingAssets",
    companyName: "CPP",
    productName: "DiTTA NN2",
    productVersion: "1.0",
  };

  const canvas = document.getElementById("unityContainer2");
  return createUnityInstance(canvas, config, (p) => {
    console.log(`NN2 loading: ${Math.round(p * 100)}%`);
  }).then((unityInstance) => {
    window.unityInstance2 = unityInstance;
    console.log("NN2 Unity initialized!");
  }).catch((err) => console.error("NN2 failed:", err));
}

// Load both once the page is ready
window.addEventListener("DOMContentLoaded", async () => {
  await Promise.all([loadUnityNN1(), loadUnityNN2()]);
});
</script>

</body>
</html>
